{"id": "b53998910b5a91c141f890fa76fbcb7f","chunk-id": 0,"course": "D7032E","text": "This video will cover Architectural Design Patterns, a critical segment in the realm of software design. Architectural design patterns provide high-level strategies for organizing codebases, ensuring that software is scalable, maintainable, and adaptable to evolving requirements. In this video, we'll delve into four predominant patterns, each with its unique approach to structuring applications:   Layered Architecture Pattern: A staple in software design, this pattern organizes code into layers, each"}
{"id": "b53998910b5a91c141f890fa76fbcb7f","chunk-id": 1,"course": "D7032E","text": "responsible for specific functions like presentation, business logic, or data access. These distinct layers promote separation of concerns, making applications more maintainable and scalable.   Model-View-Controller (MVC) Pattern: A widely adopted pattern for designing web applications and GUIs. MVC segregates an application into three interconnected components: Model (data), View (presentation), and Controller (logic). This clear division facilitates easier testing, maintenance, and scalability."}
{"id": "b53998910b5a91c141f890fa76fbcb7f","chunk-id": 2,"course": "D7032E","text": "Microservices Pattern: This architecture pattern breaks down applications into small, independent services that run as separate processes. Each service is responsible for distinct functionality and communicates via lightweight mechanisms, like HTTP/REST. The approach is celebrated for its scalability, resilience, and flexibility in adopting new technologies.   Event-Driven Architecture Pattern: This pattern is built around the production, detection, and reaction to events. Components in this architecture"}
{"id": "b53998910b5a91c141f890fa76fbcb7f","chunk-id": 3,"course": "D7032E","text": "loosely communicate through events, promoting scalability and flexibility. It's particularly effective for systems that require real-time responsiveness and adaptability."}
{"id": "1d768b18d0caf1df834c8bb94819cc82","chunk-id": 0,"course": "D7032E","text": "These three videos cover Availability, a cornerstone in the realm of Software Quality Attributes. Ensuring that a system is consistently operational and accessible when required is no small feat. In today's digital age, where users expect 24/7 access and operations, understanding and ensuring Availability becomes paramount. This series on Availability will guide you through its nuances, offering insights into its significance, tactics for achievement, and design considerations.\u00a0 Overview  \u00a0 Tactics  \u00a0"}
{"id": "1d768b18d0caf1df834c8bb94819cc82","chunk-id": 1,"course": "D7032E","text": "Design and implementation  Here are some applied examples that highlight the importance of availability and the measures taken in software to ensure it:  1. E-Commerce Platforms:   Importance: For online retail giants like Amazon or eBay, even a minute's downtime can lead to massive revenue losses. During peak sale days, this becomes even more critical.   How it's Achieved:  Load Balancers: Distributes incoming traffic across multiple servers, ensuring no single server is overwhelmed. Geo-Replication:"}
{"id": "1d768b18d0caf1df834c8bb94819cc82","chunk-id": 2,"course": "D7032E","text": "Stores copies of data in multiple locations to ensure availability even if one location faces issues. Auto-Scaling: Automatically scales resources up or down based on demand.     2. Air Traffic Control Systems:   Importance: Downtime or unavailability can lead to catastrophic results, with planes in the air requiring real-time data for safe operations.   How it's Achieved:  Redundant Systems: Multiple backup systems are in place, ready to take over if the primary system fails. Regular System Health Checks:"}
{"id": "1d768b18d0caf1df834c8bb94819cc82","chunk-id": 3,"course": "D7032E","text": "Automated checks ensure system components are functioning as expected.     3. Online Banking and Financial Services:   Importance: Users expect 24/7 access to their funds, and any downtime can erode trust and lead to financial implications.   How it's Achieved:  Distributed Databases: Ensures that even if one database fails, the system can retrieve data from another. Failover Mechanisms: In case of failures, traffic is redirected to a standby system.     4. Streaming Services (like Netflix or Spotify):"}
{"id": "1d768b18d0caf1df834c8bb94819cc82","chunk-id": 4,"course": "D7032E","text": "Importance: With millions of users streaming content simultaneously, ensuring continuous service is crucial for maintaining user satisfaction and subscription revenues.   How it's Achieved:  Content Delivery Networks (CDN): Distributes content across the globe, ensuring users can access it from a nearby server. Microservices Architecture: If one service (e.g., recommendations) fails, others (like playback) remain unaffected.     5. Health Monitoring Systems:   Importance: Devices like heart rate monitors or"}
{"id": "1d768b18d0caf1df834c8bb94819cc82","chunk-id": 5,"course": "D7032E","text": "insulin pumps must provide consistent readings to ensure patient safety.   How it's Achieved:  Battery Backup and Alerts: Ensures devices remain operational even during power failures. Self-Diagnostics: Regularly checks the integrity and functionality of the system.     In all these scenarios, a multidimensional approach, combining hardware and software strategies, ensures availability is maintained at the highest level."}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 0,"course": "D7032E","text": "In this video you will learn about\u00a0Behavioural design patterns, which address responsibilities of objects and how they communicate. They ensure that objects collaborate effectively, achieving flexibility and loose coupling in the process. Let's explore some pivotal Behavioural patterns:   Observer Pattern: Enables an object (known as the subject) to maintain a list of its dependents (observers) and notify them of any state changes. It's widely used when a change in one object must be reflected in another"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 1,"course": "D7032E","text": "without knowing how many objects need to be updated.   Chain of Responsibility Pattern: Decouples the sender from the receiver by allowing more than one object to handle a request. The request is passed through a chain of potential handlers until either it's handled or reaches the end of the chain.   State Pattern: Allows an object to change its behavior when its internal state changes, making it seem as if the object has changed its class.   Strategy Pattern: Defines a family of algorithms, encapsulates"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 2,"course": "D7032E","text": "each one, and makes them interchangeable. It lets the algorithm vary independently from clients that use it.   Command Pattern: Encapsulates a request as an object, allowing users to parameterize objects with operations, queue requests, and support operations like undo.   Iterator Pattern: Provides a way to access elements of an aggregate object sequentially without exposing its underlying representation.   Mediator Pattern: Centralizes external communications between a set of objects to reduce direct"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 3,"course": "D7032E","text": "dependencies and minimize the need for subclasses.   Each of these patterns provides unique solutions to common object interaction problems, ensuring a fluid dialogue between entities and resulting in more maintainable, robust software systems.  \u00a0 Observer Pattern interface Observer {     void update(); }  class ConcreteObserver implements Observer {     public void update() {         // React to the update     } }  class Subject {     List<Observer> observers = new ArrayList<>();      void"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 4,"course": "D7032E","text": "addObserver(Observer o) {         observers.add(o);     }      void notifyAllObservers() {         for (Observer o : observers) {             o.update();         }     } }  Additional information and concrete example Chain of Responsibility Pattern abstract class Handler {     Handler nextHandler;      void setNextHandler(Handler handler) {         this.nextHandler = handler;     }      abstract void handleRequest(String request); }  class ConcreteHandlerA extends Handler {     void handleRequest(String"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 5,"course": "D7032E","text": "request) {         // Handling logic or pass to next handler     } }  Additional information and concrete example State Pattern interface State {     void handle(); }  class ConcreteStateA implements State {     public void handle() {         // Handle state A     } }  class Context {     State currentState;     void setState(State state) {         this.currentState = state;     } }  Additional information and concrete example Strategy Pattern interface Strategy {     void execute(); }  class"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 6,"course": "D7032E","text": "ConcreteStrategyA implements Strategy {     public void execute() {         // Execute strategy A     } }  class Context {     Strategy strategy;     void setStrategy(Strategy strategy) {         this.strategy = strategy;     }     void executeStrategy() {         strategy.execute();     } }  Additional information and concrete example Command Pattern interface Command {     void execute(); }  class ConcreteCommandA implements Command {     public void execute() {         // Execute action A     } }  class"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 7,"course": "D7032E","text": "Invoker {     Command command;     void setCommand(Command cmd) {         this.command = cmd;     }     void invoke() {         command.execute();     } }  Additional information and concrete example Iterator Pattern interface Iterator {     boolean hasNext();     Object next(); }  class ConcreteIterator implements Iterator {     public boolean hasNext() {         // Check if there's a next element     }     public Object next() {         // Return the next element     } }  Additional information and"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 8,"course": "D7032E","text": "concrete example Mediator Pattern interface Mediator {     void notify(String event, Component component); }  class ApplicationMediator implements Mediator {     public void notify(String event, Component component) {         // Handle component notifications     } }  abstract class Component {     Mediator mediator;     public Component(Mediator mediator) {         this.mediator = mediator;     }     public abstract void doAction(); }  class Button extends Component {     public Button(Mediator mediator) {"}
{"id": "acd87690df4ee4fdcc25e7fc2d139295","chunk-id": 9,"course": "D7032E","text": "super(mediator);     }     public void doAction() {         // Do button related action         mediator.notify(\"ButtonPressed\", this);     } }  class Textbox extends Component {     public Textbox(Mediator mediator) {         super(mediator);     }     public void doAction() {         // Do textbox related action         mediator.notify(\"TextboxUsed\", this);     } }  Additional information and concrete example"}
{"id": "9d9b9e9721bd6ba378242fb3b3eb6feb","chunk-id": 0,"course": "D7032E","text": "This video covers Booch's metrics, a seminal framework in software design that aids in evaluating and refining the architecture of software systems. Grady Booch's insights into these metrics provide a roadmap for understanding and optimizing software design quality. As we venture into the video, here's a brief primer on the five metrics you'll encounter:   Coupling: Measures the degree of interdependence between software modules. Lower coupling is generally favored as it implies modules can operate more"}
{"id": "9d9b9e9721bd6ba378242fb3b3eb6feb","chunk-id": 1,"course": "D7032E","text": "independently, enhancing maintainability and scalability.   Cohesion: Refers to how closely the responsibilities of a single module are related to one another. Higher cohesion suggests that a module is focused and easy to understand, modify, and maintain.   Sufficiency: Assesses if the provided components of a system offer enough functionality to satisfy its requirements. A system is deemed sufficient if its architecture supports its intended behaviors.   Completeness: Gauges whether all required components"}
{"id": "9d9b9e9721bd6ba378242fb3b3eb6feb","chunk-id": 2,"course": "D7032E","text": "of the system are present and correctly interact with each other. A complete system doesn't leave any required aspect or functionality unaddressed.   Primitiveness: Evaluates the simplicity of components. It encourages software design where complex functions are composed of simple, single-purpose operations, promoting ease of testing and reusability."}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 0,"course": "D7032E","text": "This video is on Cloud design patterns, a specialized set of solutions tailored for the ever-evolving world of cloud computing. As the demands on cloud systems increase, so does the complexity of challenges they face, ranging from system availability and scalability to ensuring consistent and responsive user experiences. This video covers some pivotal cloud design patterns that act as roadmaps to building robust and resilient cloud-native applications:   Asynchronous Request and Reply Pattern: Facilitates"}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 1,"course": "D7032E","text": "asynchronous communication between services, ensuring non-blocking operations and more responsive systems.   Command and Query Responsibility Segregation (CQRS) Pattern: Separates read and write actions, optimizing scalability and flexibility of your cloud applications.   Event Sourcing Pattern: Captures the state changes as events, allowing systems to reconstruct past states and offering better traceability.   Retry Pattern: Implements automatic retries for failed operations, enhancing system resilience"}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 2,"course": "D7032E","text": "especially when temporary issues occur.   Circuit Breaker Pattern: Detects failures and prevents the system from trying to perform a function that's likely to fail, protecting system overloads and cascading failures.   Bulkhead Pattern: Isolates elements of an application into pools, ensuring failures in one won\u00e2\u20ac\u2122t lead to system-wide collapse.   Throttling Pattern: Regulates the rate at which application events are processed, ensuring controlled resource consumption and optimal performance.   Queue-based"}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 3,"course": "D7032E","text": "Load Levelling Pattern: Uses a queue to manage and level the load to system components, ensuring smooth operation even during traffic spikes.    \u00a0 Creating Java-based examples for cloud patterns is a bit challenging, as many of these patterns rely on specific cloud infrastructure elements that Java by itself doesn't encapsulate, so these are rudimentary examples. In real-world cloud scenarios, these patterns might be implemented using cloud-specific libraries, services, or frameworks. Asynchronous request"}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 4,"course": "D7032E","text": "and reply pattern public class AsyncRequestReply {     public void sendRequest(String message) {         // Logic to send an asynchronous request     }          public Response receiveReply() {         // Logic to receive a reply asynchronously         return new Response();     } }   Additional information and concrete example CQRS pattern public interface Command {     void execute(); }  public interface Query {     Object fetch(); }   Additional information and concrete example Event sourcing pattern"}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 5,"course": "D7032E","text": "public class Event {     private final String action;     private final Date timestamp;          // Constructor, getters and setters }   Additional information and concrete example Retry pattern public class RetryOperation {     private static final int MAX_RETRIES = 3;          public void operationWithRetry() {         int retryCount = 0;         while (retryCount < MAX_RETRIES) {             // Try the operation                          if (/* operation is successful */) {                 break;"}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 6,"course": "D7032E","text": "}             retryCount++;         }     } }   Additional information and concrete example Circuit breaker pattern (Note: This is a highly simplified version; real-world usage might rely on libraries like Resilience4j) public class CircuitBreaker {     // Logic for monitoring failures and opening/closing the circuit          public void execute() {         if (/* circuit is closed */) {             // Perform the operation         }     } }   Additional information and concrete example Bulkhead pattern"}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 7,"course": "D7032E","text": "(Conceptual example) public class Bulkhead {     // Logic to limit the number of concurrent operations          public void performLimitedOperation() {         // Ensure only a limited number of operations occur concurrently     } }   Additional information and concrete example Throttling pattern (Conceptual example) public class Throttle {     // Logic to ensure rate limits are not exceeded          public void performRateLimitedOperation() {         // Ensure operation does not exceed rate limits     } }"}
{"id": "e64e824c583f9168f0b6fd48c8369b2a","chunk-id": 8,"course": "D7032E","text": "Additional information and concrete example Queue-based load levelling pattern (Conceptual example) public class LoadLeveler {     // Logic to place requests into a queue          public void enqueueRequest(Request request) {         // Add request to queue for later processing     } }   Additional information and concrete example"}
{"id": "605685f78a2888e768018c650728e3eb","chunk-id": 0,"course": "D7032E","text": "This video will cover concurrency design patterns. As we venture into the world of concurrent and parallel programming, certain challenges arise, such as ensuring data consistency, managing thread access, and optimizing performance. Concurrency design patterns provide us with tried-and-true solutions to tackle these challenges. In this video, we'll delve into:   Monitor Pattern: This pattern synchronizes method calls, ensuring that only one method is active at a time in a given object, thus preserving the"}
{"id": "605685f78a2888e768018c650728e3eb","chunk-id": 1,"course": "D7032E","text": "object's state integrity.   Lock Pattern: A strategy that provides mutual exclusion to ensure that only one thread can execute the lock-protected region of the code at a time. This pattern is fundamental for preventing race conditions.   Read-write Lock Pattern: This pattern allows concurrent reading of data while still ensuring that writes are atomic and isolated. This ensures that while multiple threads can read data simultaneously, only one can write to it, thus ensuring data integrity.   Scheduler"}
{"id": "605685f78a2888e768018c650728e3eb","chunk-id": 2,"course": "D7032E","text": "Pattern: It determines how threads or tasks get access to resources or processors based on scheduling algorithms. This ensures fairness and optimizes the overall system's performance.   Thread Pool Pattern: Instead of initiating and destroying threads on the fly, which can be resource-intensive, this pattern keeps a pool of worker threads ready to perform tasks. It optimizes system resources and ensures efficient execution of concurrent tasks.   Each pattern is a tool in our concurrency toolkit, ensuring"}
{"id": "605685f78a2888e768018c650728e3eb","chunk-id": 3,"course": "D7032E","text": "our applications are robust, efficient, and maintainable. Let's dive deep into each of these and see how they help us build better concurrent software.  Monitor pattern public class MonitorObject {}  public class SynchronizedObject {     private final MonitorObject monitor = new MonitorObject();      public void doSynchronizedWork() {         synchronized(monitor) {             // Critical section         }     } }  Lock pattern import java.util.concurrent.locks.Lock; import"}
{"id": "605685f78a2888e768018c650728e3eb","chunk-id": 4,"course": "D7032E","text": "java.util.concurrent.locks.ReentrantLock;  public class LockExample {     private final Lock lock = new ReentrantLock();      public void doLockedWork() {         lock.lock();         try {             // Critical section         } finally {             lock.unlock();         }     } }  Read-write lock pattern import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock;  public class ReadWriteLockExample {     private final ReadWriteLock lock = new"}
{"id": "605685f78a2888e768018c650728e3eb","chunk-id": 5,"course": "D7032E","text": "ReentrantReadWriteLock();      public void readData() {         lock.readLock().lock();         try {             // Read data         } finally {             lock.readLock().unlock();         }     }      public void writeData() {         lock.writeLock().lock();         try {             // Write data         } finally {             lock.writeLock().unlock();         }     } }  Scheduler pattern import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import"}
{"id": "605685f78a2888e768018c650728e3eb","chunk-id": 6,"course": "D7032E","text": "java.util.concurrent.TimeUnit;  public class SchedulerExample {     private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);      public void startTask() {         scheduler.scheduleAtFixedRate(() -> {             // Task to run         }, 0, 10, TimeUnit.SECONDS);     } }  Thread pool pattern import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors;  public class ThreadPoolExample {     private final ExecutorService executor ="}
{"id": "605685f78a2888e768018c650728e3eb","chunk-id": 7,"course": "D7032E","text": "Executors.newFixedThreadPool(5);      public void startTask(Runnable task) {         executor.submit(task);     } }"}
{"id": "6913465adbe161b7980958c32f7310f8","chunk-id": 0,"course": "D7032E","text": "In this video, we delve into the realm of Creational design patterns. These patterns deal primarily with object creation mechanisms, striving to create objects in a manner best suited to the situation. While direct object construction in a system can lead to design problems or add to its complexity, Creational patterns provide ways to instantiate single objects or groups of related objects.\u00a0As you progress through this video, we'll explore four pivotal structural design patterns, each offering unique"}
{"id": "6913465adbe161b7980958c32f7310f8","chunk-id": 1,"course": "D7032E","text": "solutions to common challenges:   The Singleton Pattern: Ensures that a particular class has only one instance throughout the application and provides a global point of access to that instance. Useful for controlling access to shared resources.   The Factory Method Pattern: A method for creating objects in a superclass but allows subclasses to alter the type of created objects. This provides a way to delegate the instantiation logic to child classes.   The Abstract Factory Method: Produces families of"}
{"id": "6913465adbe161b7980958c32f7310f8","chunk-id": 2,"course": "D7032E","text": "related objects without specifying their concrete classes. It usually involves multiple Factory Methods, one for each type of object to be created.   The Builder Pattern: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations. Especially beneficial when an object needs to be created with many optional components or configurations.   \u00a0  \u00a0  Singleton         public class Singleton {             private static Singleton"}
{"id": "6913465adbe161b7980958c32f7310f8","chunk-id": 3,"course": "D7032E","text": "instance;             private Singleton() {}             public static Singleton getInstance() {                 if (instance == null) {                     instance = new Singleton();                 }                 return instance;             }         } Additional information and concrete example Factory Method         abstract class Product {}         class ConcreteProduct extends Product {}            abstract class Creator {             public abstract Product factoryMethod();         }"}
{"id": "6913465adbe161b7980958c32f7310f8","chunk-id": 4,"course": "D7032E","text": "class ConcreteCreator extends Creator {             public Product factoryMethod() { return new ConcreteProduct(); }         } Additional information and concrete example Abstract Factory         interface Button {}         class WinButton implements Button {}         class MacButton implements Button {}            interface Factory {             Button createButton();         }         class WinFactory implements Factory {             public Button createButton() { return new WinButton(); }         }"}
{"id": "6913465adbe161b7980958c32f7310f8","chunk-id": 5,"course": "D7032E","text": "class MacFactory implements Factory {             public Button createButton() { return new MacButton(); }         } Additional information and concrete example Builder         class Product {             String partA;             String partB;             // setters and getters...         }            class Builder {             Product product = new Product();             void buildPartA(String part) { product.setPartA(part); }             void buildPartB(String part) { product.setPartB(part); }"}
{"id": "6913465adbe161b7980958c32f7310f8","chunk-id": 6,"course": "D7032E","text": "Product getResult() { return product; }         }  Additional information and concrete example"}
{"id": "1c7a8d821752a264f469bb4df4e74b05","chunk-id": 0,"course": "D7032E","text": "This video introduces Design Patterns, an essential toolset for every software designer looking to solve common challenges in innovative ways. These patterns provide tested, proven solutions to recurring software design issues, making software more maintainable, understandable, and reliable. As we embark on this journey, here's an overview of the six distinct areas of design patterns we'll delve into in subsequent videos:   Creational Design Patterns: Focus on the best ways to create objects, promoting"}
{"id": "1c7a8d821752a264f469bb4df4e74b05","chunk-id": 1,"course": "D7032E","text": "flexibility and reusability by abstracting the instantiation process.   Structural Design Patterns: Concerned with the composition of classes or objects, they ensure the structure is established efficiently, optimizing relationships and connections between different components.   Behavioural Design Patterns: Revolve around the distribution of responsibilities between objects, promoting better interaction and increased flexibility.   Concurrency Design Patterns: Address multi-threading and parallel"}
{"id": "1c7a8d821752a264f469bb4df4e74b05","chunk-id": 2,"course": "D7032E","text": "computation issues, ensuring that software operations run smoothly without conflicts or inefficiencies.   Cloud Design Patterns: Special patterns that address challenges unique to cloud-based applications, optimizing scalability, resilience, and performance in cloud environments.   Architectural Design Patterns: Focus on high-level structuring of software components, providing blueprints for defining component interactions and overall system architecture."}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 0,"course": "D7032E","text": "Prerequisite:  Make sure you have started to go through the Modular course on Software design and architecture (available in the Modules tab in canvas). For this assignment you need to have completed the Design principles and Design patterns sections. Objective:You have been provided with three different implementations of an inventory system for a text-based dungeon crawler game. Your task is to critically analyze each implementation with respect to the SOLID principles and Booch metrics. For the final"}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 1,"course": "D7032E","text": "implementation, you are also expected to identify a specific design pattern used. Use your understanding of software design principles to reason about the strengths and weaknesses of each approach. Instructions:   Inventory as a Simple List in Player Class  public class Player {     private List<Item> inventory = new ArrayList<>();        public void addToInventory(Item item) {         inventory.add(item);     }        public void removeFromInventory(Item item) {         inventory.remove(item);     }"}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 2,"course": "D7032E","text": "// ...other player methods... }   Review the given code. Identify which SOLID principles are adhered to and which ones are violated. Provide reasoning. Analyze the code in terms of Booch metrics. Discuss potential impacts on maintainability, flexibility, and extensibility.    Inventory as a Separate Class  public class Inventory {     private List<Item> items = new ArrayList<>();        public void add(Item item) {         items.add(item);     }        public void remove(Item item) {"}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 3,"course": "D7032E","text": "items.remove(item);     } }  public class Player {     private Inventory inventory = new Inventory();        public void addToInventory(Item item) {         inventory.add(item);     }        public void removeFromInventory(Item item) {         inventory.remove(item);     }        // ...other player methods... }   Review the given code. Again, identify which SOLID principles are adhered to and which ones are violated. Provide reasoning. Analyze the code in terms of Booch metrics. Compare this to the previous"}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 4,"course": "D7032E","text": "implementation and discuss any improvements or regressions.    Inventory with Design Pattern  public interface Inventory {     void add(Item item);     void remove(Item item);     boolean canAdd(Item item); }  public class SimpleInventory implements Inventory {     private List<Item> items = new ArrayList<>();        public void add(Item item) {         if(canAdd(item)) {             items.add(item);         }     }        public void remove(Item item) {         items.remove(item);     }      public boolean"}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 5,"course": "D7032E","text": "canAdd(Item item) {         return items.size() < 10; // Let's say a simple inventory can hold only 10 items.     } }  public class MagicianInventory implements Inventory {     private List<Item> items = new ArrayList<>();     private double totalWeight = 0;        public void add(Item item) {         if(canAdd(item)) {             items.add(item);             totalWeight += item.getWeight();         }     }        public void remove(Item item) {         items.remove(item);         totalWeight -="}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 6,"course": "D7032E","text": "item.getWeight();     }      public boolean canAdd(Item item) {         return totalWeight + item.getWeight() <= 50; // Let's say a magician can only carry items with total weight <= 50 units.     } }  public class Player {     private Inventory inventory;        public Player(Inventory inventory) {         this.inventory = inventory;     }        public void addToInventory(Item item) {         if(inventory.canAdd(item)) {             inventory.add(item);         }     } }   Review the given code. As"}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 7,"course": "D7032E","text": "before, identify which SOLID principles are adhered to and which ones are violated. Provide reasoning. Analyze the code in terms of Booch metrics. Identify the design pattern used in this implementation. Describe how this pattern affects the design's adherence to SOLID principles and its impact according to Booch metrics.    Tips:  Think about how each implementation might evolve over time. How easy would it be to add new features or modify existing ones? Consider the effect of class coupling and cohesion"}
{"id": "0966305680643bab0d284777a1baff70","chunk-id": 8,"course": "D7032E","text": "on each design. How does each design decision impact understandability, complexity, and the potential for errors?  Submission:Provide a written analysis for each of the three implementations. Each analysis should be detailed and well-reasoned, drawing upon your understanding of the SOLID principles, Booch metrics, and software design patterns. Ensure that your analyses are organized, and any references to the code are clear. Include any additional observations or recommendations for further improvement of"}
{"id": "068f32975e76d38b374acf1fe18c4cb6","chunk-id": 0,"course": "D7032E","text": "As we conclude our journey into Software Design and Architecture, it's time for reflection. From the foundational SOLID principles and Booch's metrics to the vast realm of design patterns and the nuances of software quality attributes, we've traversed a comprehensive landscape. Through real-world examples and hands-on exercises, you have had the opportunity to transform theory into practical understanding. But remember, learning doesn't end here. Software design is ever-evolving, urging us to stay curious"}
{"id": "068f32975e76d38b374acf1fe18c4cb6","chunk-id": 1,"course": "D7032E","text": "and adaptive. Thank you for your active participation in this course. May the knowledge gained here guide your future projects.  "}
{"id": "e5125686ce6bec70ee92f84f5fe87b36","chunk-id": 0,"course": "D7032E","text": "In the ever-evolving world of software, the capability for different systems, components, or modules to seamlessly work together is of paramount importance. At its core, Integrability is the ease with which software components can be combined and made to operate as a coherent unit. Whether you're aiming to integrate third-party APIs, merge software systems post-acquisition, or ensure that your various in-house modules talk to each other without a hiccup, understanding integrability is key. These videos will"}
{"id": "e5125686ce6bec70ee92f84f5fe87b36","chunk-id": 1,"course": "D7032E","text": "help you understand common hurdles faced during software integration and practical strategies to overcome them. Overview  \u00a0 Tactics  \u00a0 Design and implementation  Here are some real-world scenarios where integrability plays a vital role, alongside strategies used to achieve it:  1. E-commerce Platforms and Payment Gateways   Scenario: An e-commerce platform needs to integrate with various payment gateways to offer multiple payment options to its users.   How Integrability is Achieved:  API Integration: The"}
{"id": "e5125686ce6bec70ee92f84f5fe87b36","chunk-id": 2,"course": "D7032E","text": "e-commerce system interfaces with payment gateways using well-defined APIs. These APIs ensure standardized communication. Adapter Pattern: This design pattern is employed to translate the interface of one class into another interface that the e-commerce platform expects. It helps in dealing with incompatible interfaces of different payment gateways.     2. CRM Systems and Email Marketing Tools   Scenario: A company uses a Customer Relationship Management (CRM) system and wants to integrate it with an email"}
{"id": "e5125686ce6bec70ee92f84f5fe87b36","chunk-id": 3,"course": "D7032E","text": "marketing tool to automate marketing campaigns based on CRM data.   How Integrability is Achieved:  Webhooks: The CRM can use webhooks to notify the email tool of specific events or data changes. Middleware: Software components that can read data from the CRM, transform it as needed, and push it to the email tool.     3. Health Systems Integration   Scenario: Hospitals and clinics use different software solutions for patient records, appointment scheduling, billing, etc. For efficient operation, these"}
{"id": "e5125686ce6bec70ee92f84f5fe87b36","chunk-id": 4,"course": "D7032E","text": "systems need to communicate with each other.   How Integrability is Achieved:  Health Level 7 (HL7) Standards: This is a set of international standards for the transfer of clinical and administrative data. Enterprise Service Bus (ESB): Acts as a communication center by taking in messages from applications and routing them to their destination after necessary transformations.     4. Social Media Integration in Apps   Scenario: A mobile app allows users to sign up or log in using their social media accounts"}
{"id": "e5125686ce6bec70ee92f84f5fe87b36","chunk-id": 5,"course": "D7032E","text": "like Facebook, Google, or Twitter.   How Integrability is Achieved:  OAuth Protocols: This is a common open standard for access delegation used for token-based authentication and authorization. SDK Integration: Social media platforms offer Software Development Kits (SDKs) to ease the integration process.     5. ERP Systems and Supply Chain Management Tools   Scenario: A manufacturing company uses an ERP (Enterprise Resource Planning) system and wants to integrate it with a supply chain management tool for"}
{"id": "e5125686ce6bec70ee92f84f5fe87b36","chunk-id": 6,"course": "D7032E","text": "better tracking and analytics.   How Integrability is Achieved:  Data Integration Tools: Tools like Talend or Apache Camel help in transporting and transforming data between systems. Service-Oriented Architecture (SOA): This allows different software solutions to offer services to each other over a network via protocols like SOAP.     Each of these examples highlights the importance of designing software components that can be seamlessly integrated into different systems, enhancing functionality and user"}
{"id": "5115f09054cc86bd9733a277b5b582e2","chunk-id": 0,"course": "D7032E","text": "Module: Software design and architecture Welcome to the \"Software Design and Architecture\" module! This is an integral part of our larger course, designed to equip you with essential skills and knowledge to excel in the realm of software development. As software systems grow in complexity and scale, the importance of their underlying design and architecture becomes paramount. A strong foundation in these areas ensures that systems are easy to understand, maintain, and are robust. Whether you are an aspiring"}
{"id": "5115f09054cc86bd9733a277b5b582e2","chunk-id": 1,"course": "D7032E","text": "software developer or an experienced programmer looking to elevate your skills, this module offers insights and practices that are crucial in the contemporary software landscape. This module is divided into two parts. The initial segment introduces Design Principles, focusing on SOLID Principles and Booch's metrics, and segues into Design Patterns. The latter part sheds light on Software Quality Attributes. To support your learning, there is a blend of videos and exercises. Importantly, after each section,"}
{"id": "5115f09054cc86bd9733a277b5b582e2","chunk-id": 2,"course": "D7032E","text": "there is a live sessions, delving deeper into practical applications, further examples, and interactive discussions, ensuring a rounded grasp of the core concepts.  \u00a0 \u00a0 "}
{"id": "e26a772179c2583296d762f9d44089c9","chunk-id": 0,"course": "D7032E","text": "These videos cover the Modifiability Software Quality Attribute. In the rapidly evolving landscape of technology, software systems cannot remain static; they must adapt, evolve, and grow in response to user needs, environmental changes, and business dynamics. Modifiability captures the system's ability to gracefully accommodate these changes without inducing high costs or unexpected side-effects. The videos will present why it's a coveted attribute, the challenges in achieving it, and strategies to design"}
{"id": "e26a772179c2583296d762f9d44089c9","chunk-id": 1,"course": "D7032E","text": "software that can easily be modified, extended, or restructured. Overview  \u00a0 Tactics  \u00a0 Design and implementation  Here are some applied examples from a source code and code structure perspective:  1. Refactoring Legacy Code   Scenario: An old payroll application has a single class that calculates salary, taxes, and bonuses.   Modifiability Practice:  Extract Method: Segregate the large functions into smaller ones, such as calculateSalary(), calculateTax(), and calculateBonus(). Move Method: Move related"}
{"id": "e26a772179c2583296d762f9d44089c9","chunk-id": 2,"course": "D7032E","text": "functionalities to appropriate classes \u00e2\u20ac\u201c tax calculations might be moved to a TaxCalculator class.     2. Expanding a Web Application's Capabilities   Scenario: A basic web application serves static content. There's a need to introduce user authentication.   Modifiability Practice:  Use Middleware: Incorporate middleware like Express.js's middleware for user authentication. This modular approach ensures that the core application remains unchanged while new features are layered on. Separate Concerns: The"}
{"id": "e26a772179c2583296d762f9d44089c9","chunk-id": 3,"course": "D7032E","text": "user authentication logic should not mingle with content-serving logic. Separate modules or classes should be introduced.     3. Adapting to Different Database Systems   Scenario: A product was initially developed using a relational database. Due to scalability needs, there's a switch to NoSQL databases.   Modifiability Practice:  Repository Pattern: Use a repository pattern to abstract database operations. Whether it's SQL or NoSQL, the underlying operations are abstracted away. Strategy Pattern: This"}
{"id": "e26a772179c2583296d762f9d44089c9","chunk-id": 4,"course": "D7032E","text": "allows the application to switch between different database strategies without altering the code that uses the database.     4. Changing UI Themes in Desktop Applications   Scenario: A desktop application with a fixed theme now requires multiple theme support.   Modifiability Practice:  Bridge Pattern: Separate the application's abstraction from its implementation, allowing the themes to vary independently. Encapsulation: Encapsulate theme-related properties and behaviors in dedicated classes, such as"}
{"id": "e26a772179c2583296d762f9d44089c9","chunk-id": 5,"course": "D7032E","text": "DarkTheme or LightTheme.     5. Integrating New Payment Methods in E-commerce Systems   Scenario: An e-commerce system supporting credit card payments now needs to include cryptocurrency payments.   Modifiability Practice:  Factory Pattern: Use a payment factory to instantiate appropriate payment methods. This way, adding a new payment method just requires extending the factory, without changing existing code. Decorator Pattern: Allows functionalities to be added to objects dynamically. For instance, if"}
{"id": "e26a772179c2583296d762f9d44089c9","chunk-id": 6,"course": "D7032E","text": "there\u00e2\u20ac\u2122s a need to add a transaction fee for a specific payment method, this can be achieved without altering the core payment class.     In each of these cases, the emphasis is on ensuring that the source code is organized, modular, and follows well-defined principles and patterns, making it easier to modify, extend, and maintain."}
{"id": "2e8c901f4e65fd01090d77357743f502","chunk-id": 0,"course": "D7032E","text": "These videos cover Performance, a critical software quality attribute that ensures an application's responsiveness and efficiency. They will describe how performance shapes the user experience, affecting everything from load times to real-time processing. Discover the techniques developers employ to ensure systems can handle the demands of their users, and learn the significance of metrics, benchmarks, and profiling in evaluating and improving a system's performance. As modern software continues to evolve,"}
{"id": "2e8c901f4e65fd01090d77357743f502","chunk-id": 1,"course": "D7032E","text": "mastering the intricacies of performance has never been more essential. Overview  \u00a0 Tactics  \u00a0 Design and implementation  Here are some applied examples illustrating the importance of performance in various scenarios, and how it's achieved in the software:  1. Online Multiplayer Games:  Importance: Gamers expect real-time interaction. Any lag can diminish the gaming experience or provide unfair advantages. Achieving Performance:  Optimized Networking: Usage of UDP (User Datagram Protocol) for faster data"}
{"id": "2e8c901f4e65fd01090d77357743f502","chunk-id": 2,"course": "D7032E","text": "transmission with error recovery mechanisms in place. Efficient Graphics Rendering: Employing techniques like Level of Detail (LoD) to render objects differently based on their distance from the player.     2. Stock Trading Platforms:  Importance: Milliseconds can mean the difference between profit and loss. Achieving Performance:  Low Latency Data Streams: Utilizing specialized protocols and dedicated networks. In-Memory Databases: For rapid transaction processing and data retrieval.     3. E-Commerce"}
{"id": "2e8c901f4e65fd01090d77357743f502","chunk-id": 3,"course": "D7032E","text": "Websites on Black Friday:  Importance: Heavy traffic surges require the platform to handle thousands of requests per second without crashing. Achieving Performance:  Load Balancers: Distributing incoming traffic across multiple servers. Caching Mechanisms: Storing frequently accessed data in memory to reduce the load on databases. Concurrency: Using multi-threading or asynchronous frameworks to handle multiple user requests without waiting for tasks like I/O operations to complete.     4. Augmented Reality"}
{"id": "2e8c901f4e65fd01090d77357743f502","chunk-id": 4,"course": "D7032E","text": "(AR) Applications:  Importance: AR requires immediate processing to overlay virtual objects on the real world seamlessly. Achieving Performance:  Hardware Acceleration: Leveraging GPU capabilities for intensive graphics tasks. Optimized Algorithms: For real-time image and pattern recognition.     5. Emergency Response Systems:  Importance: During emergencies, rapid data retrieval and processing can save lives. Achieving Performance:  Real-time Operating Systems (RTOS): Ensuring immediate response to time-"}
{"id": "2e8c901f4e65fd01090d77357743f502","chunk-id": 5,"course": "D7032E","text": "critical tasks. Dedicated Communication Channels: To ensure that vital information isn't delayed by other non-essential communications.     Each of these scenarios underscores the pivotal role performance plays in user satisfaction, operational success, and in some cases, safety and well-being. The techniques and strategies employed to achieve high performance are tailored to the unique demands of each application."}
{"id": "29744c727eadcf440638bbad1b73bdd9","chunk-id": 0,"course": "D7032E","text": "In this part of the course on software design and architecture we will cover an often-underestimated yet critical dimension: Software Quality Attributes. Software Quality Attributes describe the non-functional requirements of a software system. While functional requirements define the \"what\" aspect (like features or functionalities), quality attributes focus on the \"how\" aspect. They specify how well the system performs its functions. Quality attributes give us insights into characteristics like the"}
{"id": "29744c727eadcf440638bbad1b73bdd9","chunk-id": 1,"course": "D7032E","text": "system's reliability, maintainability, performance, and more. They play a pivotal role in ensuring that software systems are robust, resilient, and meet users' expectations in real-world conditions. In this foundational video and the ones that follow, we'll delve into some key Software Quality Attributes, exploring their intricacies and importance. The material covering the Software Quality Attributes will contain overview and purpose of each quality attribute, tactics which can be used to achieve the"}
{"id": "29744c727eadcf440638bbad1b73bdd9","chunk-id": 2,"course": "D7032E","text": "quality attribute, and general design and implementation considerations. System and software quality attributes are covered by the ISO/IEC 25010:2011 standard and this series of videos will only cover a few of the many available Software Quality Attributes, namely:\u00a0  Availability: The degree to which a system is operational and accessible when needed. Modifiability: The ease with which a system can accommodate changes without introducing defects. Integrability: How seamlessly various components or systems"}
{"id": "29744c727eadcf440638bbad1b73bdd9","chunk-id": 3,"course": "D7032E","text": "can be combined to function cohesively. Testability: The degree to which a system can be effectively tested to ensure it meets requirements. Performance: Evaluates how efficiently a system responds to user requests and handles its workload.  These attributes not only shape the way software is developed but also significantly influence user satisfaction and system longevity."}
{"id": "7455f66862dcc6c6d02e9421249e1b58","chunk-id": 0,"course": "D7032E","text": "This video covers the SOLID Principles, a cornerstone in object-oriented programming and design. These principles lay the foundation for creating software that's resilient, maintainable, and scalable. Before diving into the video, here's a quick overview of the five principles you'll be learning about:   S (Single Responsibility Principle): A class should have only one reason to change. It means that a class should have one, and only one, responsibility.   O (Open-Closed Principle): Software entities"}
{"id": "7455f66862dcc6c6d02e9421249e1b58","chunk-id": 1,"course": "D7032E","text": "(classes, modules, functions, etc.) should be open for extension but closed for modification. This promotes flexibility and extensibility in your designs without altering existing code.   L (Liskov Substitution Principle): Base types must be substitutable by their subtypes without affecting program correctness. In essence, if a program is using a base class, it should be able to use any of its derived classes without knowing it.   I (Interface Segregation Principle): Clients should never be forced to"}
{"id": "7455f66862dcc6c6d02e9421249e1b58","chunk-id": 2,"course": "D7032E","text": "implement interfaces they don't use. Keep interfaces specific and tailored to client needs, rather than broad and all-encompassing.   D (Dependency Inversion Principle): High-level modules should not depend on low-level modules, but both should depend on abstractions. This helps in decoupling software modules, making them more modular and easily maintainable."}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 0,"course": "D7032E","text": "SOLID Principles 1. Single Responsibility Principle (SRP) - Solution: The original code violated the SRP by combining both the user's properties and operations like saving to the database and sending emails. By separating each responsibility into its class (`User`, `Database`, and `EmailService`), we adhere to the SRP by ensuring that each class has only one reason to change.  class User {     String name;     String email; }  class Database {     void saveUser(User user) {         // Code to save user data"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 1,"course": "D7032E","text": "to the database     } }  class EmailService {     void sendEmail(String email) {         // Code to send an email     } }  2. Open/Closed Principle (OCP) - Solution: To satisfy the OCP, we introduced the `Shape` interface with an `area()` method. The `Rectangle` class implements this interface. The `AreaCalculator` class, which was dependent on the concrete implementation of `Rectangle`, now depends on the abstraction (`Shape`). This allows us to add more shapes in the future without modifying the"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 2,"course": "D7032E","text": "`AreaCalculator`.  interface Shape {     double area(); }  class Rectangle implements Shape {     public double width;     public double height;          @Override     public double area() {         return width * height;     } }  class AreaCalculator {     public double computeArea(Shape shape) {         return shape.area();     } }  3. Liskov Substitution Principle (LSP) - Solution: The LSP is violated in the initial code because substituting a `Bird` object with an `Ostrich` object would lead to"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 3,"course": "D7032E","text": "unintended behaviors, as ostriches can't fly. Throwing an exception in an overridden method, like the `fly` method for `Ostrich`, could lead to unpredicted behaviors and errors at runtime. To resolve the violation of the Liskov Substitution Principle, we can separate the flying behavior from the Bird class. We can introduce interfaces that allow specific behaviors to be assigned to the classes that require them. In this way, we no longer expect every bird to be able to fly.  interface FlyingBird {     void"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 4,"course": "D7032E","text": "fly(); }  class Bird {     // common attributes and behaviors of all birds }  class Sparrow extends Bird implements FlyingBird {     @Override     public void fly() {         // flying mechanism for sparrows     } }  class Ostrich extends Bird {     // Ostrich doesn't implement FlyingBird, so no fly method here }  By introducing the `FlyingBird` interface, we ensure that only birds capable of flying will implement the `fly` method. This aligns with the Liskov Substitution Principle, as now, any bird type"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 5,"course": "D7032E","text": "that is said to be a `FlyingBird` truly has the capability to fly, ensuring substitutability. The `Ostrich` class, for instance, doesn't implement the `FlyingBird` interface, so we don't expect it to have a `fly` method. This design avoids forcing non-flying birds to provide an incorrect or exception-throwing implementation of the `fly` method. 4. Interface Segregation Principle (ISP) - Solution: The Interface Segregation Principle states that no client should be forced to depend on methods it does not use."}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 6,"course": "D7032E","text": "By breaking down the generic Worker interface into more specific interfaces (Workable, Eatable, and Sleepable), we ensure that classes like Robot only need to implement the methods that are relevant to them. In this refactored design, Robot implements only the Workable interface and avoids unnecessary methods like eat() and sleep().  interface Workable {     void work(); }  interface Eatable {     void eat(); }  interface Sleepable {     void sleep(); }  class Robot implements Workable {     @Override"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 7,"course": "D7032E","text": "public void work() {         // work code for robot     }          // Now, the Robot doesn't need to implement eat() and sleep() }  5. Dependency Inversion Principle (DIP) - Solution: The DIP is about depending on abstractions, not on concrete implementations. In the solution, the `Switch` class doesn't depend directly on the `LightBulb` class, but on the `Switchable` interface. This makes the system more flexible and allows us to control other devices (not just a `LightBulb`) using the same `Switch`."}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 8,"course": "D7032E","text": "interface Switchable {     void turnOn();     void turnOff(); }  class LightBulb implements Switchable {     @Override     public void turnOn() {         // code to turn on the light bulb     }      @Override     public void turnOff() {         // code to turn off the light bulb     } }  class Switch {     private Switchable device;      public Switch(Switchable device) {         this.device = device;     }      void operate() {         // code to operate the switch and use device.turnOn() or"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 9,"course": "D7032E","text": "device.turnOff()     } }  Booch's metrics 1. Cohesion Exercise: Answer: The UserHandler class displays low cohesion. It handles tasks like database management, email communications, and discount calculations all within one class. To improve cohesion:    Separate database operations into a DatabaseHandler or UserRepository class. Move email operations to a EmailService class. Put discount-related operations in a DiscountCalculator or UserDiscountService class.    This way, each class focuses on a single"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 10,"course": "D7032E","text": "responsibility, increasing its cohesion.  2. Coupling Exercise: Answer: The Inventory class and the Item class display tight coupling since the Inventory class directly accesses the Item class's public price attribute. To reduce the coupling:    Make the price attribute in the Item class private. Ensure that the Inventory class interacts with the Item class only through the getPrice() method or other public methods. Avoid direct manipulation or access of another class's attributes, instead preferring"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 11,"course": "D7032E","text": "method-based interaction for encapsulation.    This adjustment would make sure that the internal details of the Item class are hidden from Inventory, and any changes in the Item class will not directly impact the workings of Inventory. This reduces the coupling between the two classes.  3. Primitiveness Exercise: Answer: The Order class shows a good level of primitiveness. Each method in the class is focused on a specific, smaller task and the main method, processOrder, orchestrates them. The decomposition"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 12,"course": "D7032E","text": "into smaller methods like validateOrder, calculateTotalPrice, applyDiscount, and initiateShipping is appropriate and doesn't seem to need further decomposition for the given context.  4. Sufficiency Exercise: Answer: For the Book class in an online book store system, at a minimum, we would expect the following methods and properties: Properties:    Title Author ISBN number Publisher Publication Date Price Genre/Category Number of Pages Cover Image Synopsis/Description    Methods:    Getters and setters for"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 13,"course": "D7032E","text": "all properties addToCart(): To add the book to a shopping cart. addReview(Review review): To allow users to review the book. getAverageRating(): To retrieve the average rating of the book.    This ensures that the Book class can sufficiently represent a book in the context of an online bookstore.  5. Completeness Exercise: Answer: The Calculator class, as given, is not complete for a basic calculator. While it provides methods for addition and subtraction, it lacks other basic operations. Methods to add for"}
{"id": "42aab736fb5841a9990b50adc0c418b1","chunk-id": 14,"course": "D7032E","text": "completeness:    multiply(double a, double b): For multiplication. divide(double a, double b): For division. Be sure to handle division by zero. Potentially, power(double base, double exponent) for raising to a power and sqrt(double number) for square root.    Adding these methods would make the class a more complete representation of a basic calculator.  These answers provide a comprehensive view of each exercise, highlighting the key aspects of SOLID Principles and Booch's metrics as well as their"}
{"id": "043b528fd0f282f64c96472120f42fde","chunk-id": 0,"course": "D7032E","text": "Solution: E-Commerce System Design 1. Software Quality Attributes: Modifiability: The design of the `Payment` class makes it susceptible to frequent changes as new payment methods might be introduced or existing ones modified. The code should be structured in a way that minimizes the ripple effects of these changes. For example, segregating different payment methods into separate classes or employing a strategy pattern can help in isolating changes and improving modifiability. Testability: Currently, the"}
{"id": "043b528fd0f282f64c96472120f42fde","chunk-id": 1,"course": "D7032E","text": "methods within the `Payment` class do not return any value, which makes unit testing challenging since the outcome of a payment method cannot be directly validated. By having methods return a result (e.g., a success or failure status), it becomes clearer to test and validate each method's behavior. Additionally, the direct instantiation of objects within the classes might make it difficult to mock external dependencies. Employing dependency injection can make the classes more test-friendly, allowing for the"}
{"id": "043b528fd0f282f64c96472120f42fde","chunk-id": 2,"course": "D7032E","text": "substitution of real implementations with mock ones during testing. 2. SOLID Principles: Single Responsibility Principle: The Payment class currently handles multiple payment methods. This can be refactored by having a base Payment interface and then creating separate classes for each payment method, adhering to the SRP. Open/Closed Principle: By adopting design patterns like Strategy for Payment methods, we can ensure that our system is open for extension (adding new payment methods) but closed for"}
{"id": "043b528fd0f282f64c96472120f42fde","chunk-id": 3,"course": "D7032E","text": "modification. 3. Booch's Metrics: Cohesion: The Payment class has low cohesion since it handles multiple methods of payment. By splitting each payment method into its own class, we can increase cohesion. Coupling: The classes are tightly coupled in some areas, for example, the User class has a direct reference to Cart. Utilizing dependency inversion and injecting dependencies can reduce this coupling. 4. Design Patterns: Factory Method Pattern: The `Payment` class is currently responsible for handling"}
{"id": "043b528fd0f282f64c96472120f42fde","chunk-id": 4,"course": "D7032E","text": "multiple payment methods. As the system grows and more payment methods are introduced, this class might become too complex and harder to maintain. A better approach would be to utilize the Factory Method pattern to create payment objects. For this scenario, we can introduce a `PaymentFactory` that provides a method to create a `PaymentMethod` object based on the payment type the user selects. Each specific payment method (CreditCard, PayPal, Bitcoin) would be a subclass of the `PaymentMethod` class. This"}
{"id": "043b528fd0f282f64c96472120f42fde","chunk-id": 5,"course": "D7032E","text": "design makes it easier to add or remove payment methods without altering existing code and ensures each payment method has a single responsibility.Strategy Pattern for Payment: Instead of having multiple methods within the Payment class, introduce a PaymentStrategy interface and create individual classes for CreditCard, PayPal, and Bitcoin that implement this interface. The Payment class can then use the appropriate strategy based on the user's choice."}
{"id": "ff87dda7a1064605810196c371c6e80b","chunk-id": 0,"course": "D7032E","text": "This video covers Structural Design Patterns.\u00a0 These patterns are essential in ensuring that individual components of a system come together to form a cohesive, unified whole. As you'll soon discover, they provide ways to manage relationships and dependencies between classes and objects. Here are the patterns we'll explore:   Adapter pattern: Just like a physical adapter helps two different plugs connect, the Adapter pattern allows two incompatible interfaces to work together. It's all about creating an"}
{"id": "ff87dda7a1064605810196c371c6e80b","chunk-id": 1,"course": "D7032E","text": "intermediary that transforms one interface into another.   Bridge pattern: This pattern decouples an abstraction from its implementation, allowing both to vary independently. Think of it as a bridge between the functionality abstraction and its actual implementation.   Decorator pattern: Enhancing an object's functionalities without altering its structure is where the Decorator pattern shines. It allows us to add responsibilities to objects dynamically.   Facade pattern: Offering a simplified, unified"}
{"id": "ff87dda7a1064605810196c371c6e80b","chunk-id": 2,"course": "D7032E","text": "interface to a set of interfaces in a subsystem, the Facade pattern helps hide the complexities of the system and provides a clearer, straightforward access point.   \u00a0  \u00a0 Adapter Pattern Object Adapter - This pattern uses composition to achieve adaptability between interfaces. Generally the preferred way due to having weaker coupling compared to the Class Adapter. interface Target {     void request(); } class Adaptee {     void specificRequest() { // Some specific logic here } } class Adapter implements"}
{"id": "ff87dda7a1064605810196c371c6e80b","chunk-id": 3,"course": "D7032E","text": "Target {     Adaptee adaptee = new Adaptee();     public void request() { adaptee.specificRequest(); } }  Class Adapter - This pattern uses inheritance to achieve adaptability. This is useful when the Adapter need to work in conjunction of both the Target system and the original system at the same time. interface Target {     void request(); } class Adaptee {     void specificRequest() { // Some specific logic here } } class ClassAdapter extends Adaptee implements Target {     public void request() {"}
{"id": "ff87dda7a1064605810196c371c6e80b","chunk-id": 4,"course": "D7032E","text": "specificRequest(); } }  Additional information and concrete example Bridge Pattern interface Implementation {     void operationImpl(); } abstract class Abstraction {     Implementation impl;     abstract void operation(); } class RefinedAbstraction extends Abstraction {     void operation() { impl.operationImpl(); } }  Additional information and concrete example Decorator Pattern interface Component {     void operation(); } class ConcreteComponent implements Component {     public void operation() { //"}
{"id": "ff87dda7a1064605810196c371c6e80b","chunk-id": 5,"course": "D7032E","text": "Original operation } } abstract class Decorator implements Component {     Component component; } class ConcreteDecorator extends Decorator {     public void operation() {          component.operation();          // Additional operation      } }  Additional information and concrete example Facade Pattern class SubsystemA {     void operationA() { // Operation A logic } } class SubsystemB {     void operationB() { // Operation B logic } } class Facade {     SubsystemA a = new SubsystemA();     SubsystemB b ="}
{"id": "ff87dda7a1064605810196c371c6e80b","chunk-id": 6,"course": "D7032E","text": "new SubsystemB();     void unifiedOperation() {         a.operationA();         b.operationB();     } }  Additional information and concrete example"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 0,"course": "D7032E","text": "As systems grow increasingly complex, the ability to test them effectively becomes ever more vital. These videos covers the concept of Testability - a software quality attribute that gauges the ease with which a system can be tested. The videos will present\u00a0the core concepts of testability, discuss its importance in the software development lifecycle, and offer practical strategies to enhance it. Overview  \u00a0 Tactics  \u00a0 Design and implementation  Testability is a fundamental aspect of software development,"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 1,"course": "D7032E","text": "ensuring that systems behave as expected. Testability at the source code level usually entails a mix of design decisions, coding best practices, and software structures to facilitate easier testing. Here are some examples of appications where testability is of outmost importance, and some examples of how testability is achieved in these applications:  1. E-Commerce Websites:  Importance:\u00a0Users trust these platforms with financial transactions. Bugs or vulnerabilities can lead to financial losses or"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 2,"course": "D7032E","text": "reputation damage. Achieving Testability:  Decoupled Architecture: Code is structured so that the database, server, and user interfaces are separated, allowing individual testing of each part. Dependency Injection: Rather than hard-coding dependencies, they are injected at runtime, enabling replacement with mock objects for testing. Unit Testing: Break down the checkout process into individual units (like cart addition, payment processing) and test each in isolation. Mocking: Use mock services to replicate"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 3,"course": "D7032E","text": "third-party payment systems and test how the e-commerce site interacts with them.     2. Autonomous Vehicle Software:  Importance: Lives depend on the reliability of self-driving car software. A fault can have tragic consequences. Achieving Testability:  Clear State Management: Use explicit state machines or design patterns to manage the vehicle's many states, ensuring they're testable. Isolated Side Effects: Actions that have side effects (like actuating brakes) are isolated, making it straightforward to"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 4,"course": "D7032E","text": "test logic without triggering the effect. Simulation: Create virtual environments to test the vehicle's response to various scenarios. Modularity: Ensure each component (like obstacle detection, navigation) is designed separately, making it easier to test individually.     3. Medical Software (e.g., for MRIs or pacemakers):  Importance: Inaccuracies can result in misdiagnoses or life-threatening situations. Achieving Testability:  Primitive and Pure Functions: Where possible, functions are designed without"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 5,"course": "D7032E","text": "side effects, ensuring consistent outputs for the same inputs. Configuration Files: Rather than hardcoding values (like thresholds), they are placed in external config files, making testing under different conditions easier. Hardware-in-the-loop Testing: Integrate the software with actual hardware components to run tests in real-world conditions. Boundary Testing: Check how the software behaves at the extreme acceptable limits (e.g., heart rate thresholds for pacemakers).     4. Banking Apps:  Importance:"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 6,"course": "D7032E","text": "Financial data security and accurate transaction processing are crucial. Achieving Testability:  Encapsulation: Protecting data integrity by using private variables and public getter/setter methods. Error Handling: Explicitly code for anticipated errors and provide clear error messages, making automated testing for error scenarios feasible. End-to-end Testing: Validate the entire process of, say, transferring money between accounts. Database Rollbacks: After tests, roll back the database to its original"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 7,"course": "D7032E","text": "state to ensure test data doesn't interfere with real data.     5. Flight Booking Systems:  Importance: Overbooking, wrong bookings, or incorrect fare calculations can lead to significant losses and customer dissatisfaction. Achieving Testability:  Modular Code: Break the booking system into modules (like seat selection, payment, ticket generation) to facilitate unit testing. Continuous Integration: Automated tests run at every code check-in, ensuring that new changes don't introduce defects. Scenario"}
{"id": "2125df822884db3399f04bd1924b5205","chunk-id": 8,"course": "D7032E","text": "Testing: Simulate specific user behaviors, like booking a round trip, to test the system's response. State Transition Testing: Ensure the system correctly moves from one state to another, like from 'booking' to 'ticket confirmed'.     In each example, testability ensures that the software can be thoroughly vetted, guaranteeing that it performs reliably in critical situations."}
{"id": "a3462f807ae21be37cde2b9bcdf76671","chunk-id": 0,"course": "D7032E","text": "Exercise: Identifying Design Patterns in Real-world Projects Your task will be to identify, analyze, and document the use of design patterns within the chosen GitHub project. Instructions:  Pattern Identification: As you study the code, look out for implementations that seem to match known design patterns. Identify at least three such design patterns used in the project. UML Diagrams: For each of the design patterns you identify, create a UML diagram that captures how the pattern has been implemented in the"}
{"id": "a3462f807ae21be37cde2b9bcdf76671","chunk-id": 1,"course": "D7032E","text": "code. Ensure your diagram represents classes, relationships, methods, and other relevant components clearly. Pattern Analysis: For each pattern, provide a brief analysis that covers:  Purpose: Why do you believe this pattern was used in the design? What problem does it solve within the context of the project? Consequences: Discuss the consequences of using this pattern. How does it affect different quality attributes of the system?    Remember, the goal is not just to identify patterns but also to"}
{"id": "a3462f807ae21be37cde2b9bcdf76671","chunk-id": 2,"course": "D7032E","text": "understand their role in the context of a real-world application. This will deepen your appreciation of the practical applications of design patterns and help bridge the gap between theory and practice.\u00a0Test your understanding with one of the other members of your project group and form a deeper understanding of design patterns together."}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 0,"course": "D7032E","text": "SOLID Principles 1. Single Responsibility Principle (SRP): Exercise:Given the following class, identify any violations of the Single Responsibility Principle and suggest ways to refactor the code to adhere to the SRP.  class User {     String name;     String email;      void saveToDatabase() {         // Code to save user data to the database     }      void sendEmail() {         // Code to send an email     } }  2. Open/Closed Principle (OCP): Exercise:You are building a geometry application. Given the"}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 1,"course": "D7032E","text": "following class, enhance the design so that in the future it is possible to add support for more shapes without modifying the redesigned AreaCalculator class.  class Rectangle {     public double width;     public double height; }  class AreaCalculator {     public double computeArea(Rectangle rect) {         return rect.width * rect.height;     } }  3. Liskov Substitution Principle (LSP): Exercise:The following code has a violation of the Liskov Substitution Principle. Identify the problem and suggest a"}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 2,"course": "D7032E","text": "solution.  class Bird {     void fly() {         // Implementation for flying     } }  class Ostrich extends Bird {     @Override     void fly() {         throw new UnsupportedOperationException(\"Ostrich can't fly\");     } }  4. Interface Segregation Principle (ISP): Exercise:The following Worker interface violates the Interface Segregation Principle. Refactor the code to adhere to the ISP.  interface Worker {     void work();     void eat();     void sleep(); }  class Robot implements Worker {"}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 3,"course": "D7032E","text": "@Override     public void work() {         // work     }      @Override     public void eat() {         // Robots don't eat!     }      @Override     public void sleep() {         // Robots don't sleep!     } }  5. Dependency Inversion Principle (DIP): Exercise:The following LightBulb and Switch class setup violates the Dependency Inversion Principle. Modify the design to adhere to the DIP.  class LightBulb {     void turnOn() {         // turn on     }     void turnOff() {         // turn off     } }"}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 4,"course": "D7032E","text": "class Switch {     private LightBulb bulb;          void operate() {         // toggle bulb's state     } }   Booch's metrics 1. Cohesion Exercise: Given the following class, identify its level of cohesion and suggest ways to improve it:  class UserHandler {     private String name;     private String email;          public void saveToDatabase() {         // saves user to database     }      public void sendEmail() {         // sends email to user     }      public double calculateDiscount() {         //"}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 5,"course": "D7032E","text": "calculates discount for user based on purchase history     } }  2. Coupling Exercise: Review the following two classes and identify the level of coupling between them. Provide suggestions on how to reduce the coupling:  class Inventory {     public List<Item> items;      public double getTotalPrice() {         double total = 0;         for (Item item : items) {             total += item.price;         }         return total;     } }  class Item {     public double price;      public double getPrice() {"}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 6,"course": "D7032E","text": "return price;     } }  3. Primitiveness Exercise: Inspect the following class and determine if the methods provided are primitive enough, or if they need further decomposition:  class Order {     private List<Item> items;      public void processOrder() {         validateOrder();         calculateTotalPrice();         applyDiscount();         initiateShipping();     }      private void validateOrder() {         // validate the order items     }      private void calculateTotalPrice() {         // calculate"}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 7,"course": "D7032E","text": "total price     }      private void applyDiscount() {         // apply any applicable discounts     }      private void initiateShipping() {         // initiate the shipping process     } }  4. Sufficiency Exercise: Consider an online book store system. What methods and properties would you expect in the Book class to ensure its sufficiency in representing all necessary aspects of a book? 5. Completeness Exercise: Given the following class representing a simple calculator, identify if the class is complete."}
{"id": "5c0428412d0b96fd78f0f821fce8796f","chunk-id": 8,"course": "D7032E","text": "If not, what methods would you add to make it complete?  class Calculator {     public double add(double a, double b) {         return a + b;     }      public double subtract(double a, double b) {         return a - b;     } }"}
{"id": "4734622d5ca9d2c1b14956b7639fdcd6","chunk-id": 0,"course": "D7032E","text": "Integrated Exercise: E-Commerce System Design Scenario: You are given a simplified prototype of an e-commerce system. This system has classes for User, Product, Cart, Order, and Payment. The system allows a user to browse products, add them to their cart, create an order, and make a payment. The Payment class has methods for different payment types: creditCardPayment(), paypalPayment(), and bitCoinPayment(). Here's a basic representation of the system:  class User {     String name;     String email;"}
{"id": "4734622d5ca9d2c1b14956b7639fdcd6","chunk-id": 1,"course": "D7032E","text": "Cart userCart; }  class Product {     String productName;     double price; }  class Cart {     List<Product> products;      void addProduct(Product product) {         products.add(product);     } }  class Order {     User orderedBy;     Cart orderCart; }  class Payment {     void creditCardPayment() {         // process credit card payment     }      void paypalPayment() {         // process PayPal payment     }      void bitCoinPayment() {         // process Bitcoin payment     } }  Tasks:  Software"}
{"id": "4734622d5ca9d2c1b14956b7639fdcd6","chunk-id": 2,"course": "D7032E","text": "Quality Attributes: Identify and explain potential issues in the given code with respect to modifiability and testability. How would you improve the system considering these quality attributes? SOLID Principles: Point out any violations of SOLID principles in the given prototype. How can the code be refactored to better adhere to these principles? Booch's Metrics:  Cohesion: Discuss the cohesion of the Payment class. How can it be improved? Coupling: Is there any unwanted coupling between the classes? How"}
{"id": "4734622d5ca9d2c1b14956b7639fdcd6","chunk-id": 3,"course": "D7032E","text": "might you reduce it?   Design Patterns:  Identify a scenario in the given prototype where the Factory Method pattern might be beneficial. Considering the Payment class, suggest a design pattern to simplify the process of adding new payment methods in the future."}
